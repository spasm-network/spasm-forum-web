<template>
  <div v-if="address && address.verified">
    <div v-if="address.value" class="text-base text-colorNotImportant-light dark:text-colorNotImportant-dark">
      <span>Author: </span>
      <ExtraBlockies
        :seed="extractValueFromAddressForDisplay(address, true)"
        :scale="2"
        class="inline-block mr-1"
      />
      <nuxt-link :to="`/authors/${address.value?.toString()}`"
        class="text-colorPrimary-light dark:text-colorPrimary-dark hover:underline">

        <!-- client-only tags solve hydration mismatch warning -->
        <client-only>
            <span
              v-if="getMetadataByAddressNostr(extractValueFromAddressForDisplay(address, true), 'username') && getMetadataByAddressNostr(extractValueFromAddressForDisplay(address, true), 'username') !== 'none'"
              class="ml-1"
            >
              <span class="">
                {{ getMetadataByAddressNostr(extractValueFromAddressForDisplay(address, true), 'username').slice(0,40) }}
              </span>
              <span class="text-sm">
                (Nostr)
              </span>
            </span>

          <span v-else class="">
            <span v-if="ens">
              {{ ens }} - 
            </span>
            {{ extractValueFromAddressForDisplay(address) }}
          </span>
        </client-only>
      </nuxt-link>

      <ExtraAddressIcons
        v-if="extractValueFromAddressForDisplay(address, true)"
        :key="extractValueFromAddressForDisplay(address, true)"
        :value="extractValueFromAddressForDisplay(address, true)"
        :showFollow="true"
        :showCopyToClipboard="true"
        :showQrCode="true"
        :showExternalWebsite="true"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import {SpasmEventAddressV2} from "@/helpers/interfaces"
import {storeToRefs} from 'pinia'
import {useProfilesStore} from '@/stores/useProfilesStore'
const profilesStore = useProfilesStore()
const {getMetadataByAddressNostr} = storeToRefs(profilesStore)
const env = useRuntimeConfig()?.public
const enableAutoGeneratedNames: boolean = env?.enableAutoGeneratedNames === 'false'? false : true
const {
  autoGeneratedName, 
} = useUtils()
// import {BrowserProvider} from "@/node_modules/ethers/lib.commonjs/ethers";
import {ethers} from "ethers";
const {
  extractValueFromAddressForDisplay
} = useWeb3()
const props = defineProps<{
  address?: SpasmEventAddressV2
  key?: string | number
}>()

const ens = ref<string>('')

if (process.client) {
  setTimeout(() => {
    lookupEns(props.address)
  }, 500)
}

// const testAddress = "0xf8553015220a857eda377a1e903c9e5afb3ac2fa"
const lookupEns = async (address: any) => {
  if (
    !address || !address.value || typeof(address.value) !== 'string' || 
    !address.value.startsWith('0x') || address.value.length !== 42
  ) {
    return null
  }
  try {
    const userProvider = new ethers.BrowserProvider(window.ethereum)
    const name = await userProvider.lookupAddress(address.value);
    ens.value = name
    return name;
  } catch (e: any) {
    console.log('error', e)
    // error.value = `Failed to lookup address: \${e.message}`;
    return null;
  } finally {
    // isLoading.value = false;
  }
}

</script>

<style scoped>
</style>